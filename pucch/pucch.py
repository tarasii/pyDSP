import sys
import numpy 
import math
import pucch_tables
import sin_cos
import pucch_cf

def base_seq_gen(u, type=0):
  #Base sequence can be generated by 
  if (type == 0):
    #1. generic math sin and cos functions
    base_seq = numpy.array([math.cos(alpha * x) + 1j * math.sin(alpha * x) for x in pucch_tables.table_5_2_2_2_2_standart[u]]) * 32767
  elif (type == 1):
    #2. sin_cos function that uses general cos aproximation tables 
    #base_seq = numpy.array([ cos_i + 1j * sin_i for sin_i, cos_i in [sin_cos.sin_cos(round(x * math.pi / 4 * 2 * 512 / math.pi)) for x in pucch_tables.table_5_2_2_2_2_standart[u]]])
    base_seq = numpy.array([ cos_i + 1j * sin_i for sin_i, cos_i in [sin_cos.sin_cos(round(x * 512 / 2)) for x in pucch_tables.table_5_2_2_2_2_standart[u]]])
  elif (type == 2):
    #3. precalculated tables
    base_seq = pucch_tables.table_5_2_2_2_2[u]
  else:
    base_seq = numpy.array([0]*12)
  
  return base_seq
  
def alpha_seq_gen(alpha, type=0):
  #Alpha sequence can be generated by 
  if (type == 0):
    #1. generic math sin and cos functions
    alpha_seq = numpy.array([math.cos(alpha * x) + 1j * math.sin(alpha * x) for x in range(0, 12)]) * 32767
  elif (type == 1):
    #2. sin_cos function that uses general cos aproximation tables
    alpha_seq = numpy.array([ cos_i + 1j * sin_i for sin_i, cos_i in [sin_cos.sin_cos(round(x * alpha * 2 * 512 / math.pi)) for x in range(0,12)]])  
  else:
    alpha_seq = numpy.array([0]*12)
    
  return alpha_seq

def o_seq_gen(N_SF, w, type=0):
  #O sequence can be generated by 
  if (type == 0):
    #1. generic math sin and cos functions
    o_seq = numpy.array([ math.cos(x * 2 * math.pi / N_SF) + 1j * math.sin(x * 2 * math.pi / N_SF) for x in pucch_tables.table_6_3_2_4_1_2_Wi_standart[N_SF][w]]) * 32768       
  elif (type == 1):
    #2. sin_cos function that uses general cos aproximation tables
    o_seq = numpy.array([ cos_i + 1j * sin_i for sin_i, cos_i in [sin_cos.sin_cos(round(x * 4 * 512 / N_SF)) for x in pucch_tables.table_6_3_2_4_1_2_Wi_standart[N_SF][w]]])        
  else:
    o_seq = numpy.array([0]*12)
    
  return o_seq

 
def pucch1(ini):
  mcs = 0
  if ini["sr"]:
    d = pucch_tables.get_d(ini["sr"], ini["ACK"], 32768)
  else:
    d = pucch_tables.get_d(ini["nr_bit"], ini["ACK"], 32768)
  d = numpy.round(d,0)  
  print(f"nr_bit:{ini['nr_bit']}, ACK:{ini['ACK']} d:{d}")
    
  w_index = ini['time_domain_occ_idx']
  s = ini["start_symbol_index"]
  nrofSymbols = ini["nrofsymbols"]
  if ini['IntraSlotFreqHopping'] == 1:
    N_SF_mprime_PUCCH_1       = pucch_tables.table_6_3_2_4_1_1_N_SF_mprime_PUCCH_1_m0Hop[nrofSymbols-1]
    N_SF_mprime_PUCCH_DMRS_1  = pucch_tables.table_6_4_1_3_1_1_1_N_SF_mprime_PUCCH_1_m0Hop[nrofSymbols-1]
  else:
    N_SF_mprime_PUCCH_1       = pucch_tables.table_6_3_2_4_1_1_N_SF_mprime_PUCCH_1_noHop[nrofSymbols-1]
    N_SF_mprime_PUCCH_DMRS_1  = pucch_tables.table_6_4_1_3_1_1_1_N_SF_mprime_PUCCH_1_noHop[nrofSymbols-1]
    
  print(f"w:{w_index}, N_SF:{N_SF_mprime_PUCCH_1}, N_SF_DMRS:{N_SF_mprime_PUCCH_DMRS_1} ")
  
  m_dmrs = 0; m_data = 0;
  res_data = numpy.array([])
  res_dmrs = numpy.array([])
  for l in range(0, nrofSymbols):
    ncs = pucch_tables.get_ncs(ini["hoppingID"], l, ini["start_symbol_index"], ini["nr_slot_tx"])
    alpha = pucch_tables.get_alpha(ncs, ini["InitialCS"], mcs)
    u, v = pucch_tables.get_group_swq_hopping(ini["GroupHopping"],ini["hoppingID"],l,ini["nr_slot_tx"]);
    print(f"l:{l}, ncs:{ncs}, alpha:{alpha}, u:{u}, v:{v}")
    
    base_seq = base_seq_gen(u, 1)
    #print(base_seq)
  
    #In my testvectors DMRS are generated with generic math sin cos and DATA with sin_cos function
    alpha_seq_dmrs = alpha_seq_gen(alpha, 0)
    alpha_seq = alpha_seq_gen(alpha, 1)
    
    x_n = alpha_seq * base_seq / 32768
    x_n_dmrs = alpha_seq_dmrs * base_seq / 32768
    #print(x_n)
    if ((l) % 2)==0:
       y_n = x_n  
       #y_n = numpy.rint(x_n) * d / 32768
       #print(numpy.round(x_n))
       #print(numpy.round(y_n))
       
       #O sequence generation DMRS
       o_seq = o_seq_gen(N_SF_mprime_PUCCH_DMRS_1, w_index, 1)
       #print(o_seq)
       
       if (m_dmrs >= len(o_seq)):
         m_dmrs = 0;
       m = m_dmrs

       y_n = numpy.rint(y_n) * o_seq[m] / 32768 
       #print(numpy.round(y_n))
       y_n = numpy.round(y_n) / 8
       #print(numpy.round(y_n))
       m_dmrs = m_dmrs + 1
       
       res_dmrs = numpy.concatenate((res_dmrs, y_n))
       
    else:

       y_n = numpy.rint(x_n) * d / 32768 
       #print(numpy.rint(x_n))
       #print(numpy.round(y_n))
       
       #O sequence generation DATA
       o_seq = o_seq_gen(N_SF_mprime_PUCCH_1, w_index, 1)
       #print(o_seq)
     
       if (m_data >= len(o_seq)):
         m_data = 0;
       m = m_data
       
       y_n = numpy.rint(y_n) * o_seq[m] / 32768 
       y_n = numpy.round(y_n) / 8 
       
       res_data = numpy.concatenate((res_data, y_n))
       m_data = m_data + 1

  return res_data, res_dmrs
  
def pucch0(ini):
  amp = 4095
  mcs = pucch_tables.get_mcs(ini["sr_flag"], ini["nr_bit"], ini["ACK"])
  print(f"sr_flag:{ini['sr_flag']}, nr_bit:{ini['nr_bit']}, payload:{ini['ACK']}, mcs:{mcs}")
  nrofSymbols = ini["nrofsymbols"]
  
  res = numpy.array([])
  for l in range(0, nrofSymbols):
    ncs = pucch_tables.get_ncs(ini["hoppingID"], l, ini["start_symbol_index"], ini["nr_slot_tx"])
    alpha = pucch_tables.get_alpha(ncs, ini["InitialCS"], mcs)
    u, v = pucch_tables.get_group_swq_hopping(ini["GroupHopping"],ini["hoppingID"],l,ini["nr_slot_tx"]);
    print(f"l:{l}, ncs:{ncs}, alpha:{alpha}, u:{u}, v:{v}")
     
    base_seq = base_seq_gen(u, 1)
    #print(base_seq)
  
    alpha_seq = alpha_seq_gen(alpha, 1)
    #print(base_seq)

    x_n = alpha_seq * base_seq / 32767
    y_n = x_n * amp / 32767
    res = numpy.concatenate((res, y_n))
    
  return res
    
def pucch(nm):
  print(nm)
  fname = f"PUCCH_TV_{nm}_pucch1.ini"
  print(fname)
  ini = pucch_cf.read_cf(fname)
  print(ini)
  
  fname = f"PUCCH_TV_{nm}_pucch1_slot_data.dat"  
  print(fname)
  v = numpy.fromfile(fname, dtype="i2").reshape((-1,2))
  ref = numpy.array([complex(*x) for x in v])
  print(ref)
  
  if ini["format"] == 0:
    res = pucch0(ini)
  elif ini["format"] == 1:
    fname = f"PUCCH_TV_{nm}_pucch1_slot_dmrs.dat"  
    print(fname)
    v = numpy.fromfile(fname, dtype="i2").reshape((-1,2))
    ref_dmrs = numpy.array([complex(*x) for x in v])
    #print(ref_dmrs)  
  
    res, res_dmrs = pucch1(ini)
    
    print (ref_dmrs-numpy.round(res_dmrs))
    #print (ref_dmrs-numpy.rint(res_dmrs))
    
  #print(ref[13], ref[14], ref[19])
  #print(numpy.round(res[13]), numpy.round(res[14]), numpy.round(res[19]))
    
    
  print (ref-numpy.round(res))
  

pucch("iter1_slot1_ue1")
#pucch("iter1_slot4_ue20")
#pucch("iter1_slot1_ue10")
#pucch("iter1_slot2_ue10")

def o_seq_generation_test(w):
  for N_SF in range(1, 8):
    o_seq = o_seq_gen(N_SF, w_index, 1)
    #print(numpy.imag(o_seq))
    #print(numpy.real(o_seq))
    print(o_seq)



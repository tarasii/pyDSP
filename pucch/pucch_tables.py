import numpy 
import math

#Table 5.2.2.2-2 (Re part) TS 38.211 Subclause 5.2.2.2 Base sequences of length less than 36 (M_ZC=12)
table_5_2_2_2_2_Re = [
  [-23170, 23170,-23170,-23170,-23170,-23170,-23170, 23170, 23170, 23170, 23170,-23170],
  [-23170,-23170, 23170,-23170, 23170,-23170, 23170, 23170, 23170,-23170,-23170,-23170],
  [-23170,-23170,-23170, 23170,-23170,-23170, 23170, 23170,-23170,-23170,-23170,-23170],
  [-23170,-23170, 23170,-23170,-23170,-23170,-23170,-23170,-23170, 23170, 23170,-23170],
  [-23170, 23170, 23170, 23170,-23170, 23170, 23170, 23170, 23170, 23170,-23170, 23170],
  [-23170,-23170,-23170, 23170,-23170,-23170,-23170, 23170,-23170, 23170, 23170,-23170],
  [ 23170, 23170,-23170, 23170, 23170, 23170,-23170, 23170, 23170, 23170, 23170,-23170],
  [ 23170,-23170,-23170, 23170,-23170,-23170,-23170, 23170, 23170, 23170, 23170,-23170],
  [-23170, 23170,-23170, 23170,-23170, 23170,-23170,-23170, 23170,-23170,-23170, 23170],
  [-23170, 23170, 23170,-23170,-23170, 23170,-23170,-23170, 23170,-23170, 23170,-23170],
  [-23170,-23170,-23170,-23170,-23170,-23170, 23170, 23170,-23170,-23170, 23170,-23170],
  [-23170, 23170,-23170, 23170, 23170,-23170,-23170,-23170, 23170, 23170, 23170,-23170],
  [-23170, 23170,-23170,-23170,-23170, 23170,-23170, 23170, 23170,-23170,-23170,-23170],
  [-23170, 23170, 23170, 23170,-23170,-23170,-23170, 23170, 23170,-23170, 23170,-23170],
  [ 23170,-23170,-23170, 23170,-23170,-23170,-23170, 23170, 23170, 23170, 23170,-23170],
  [-23170, 23170,-23170, 23170, 23170,-23170,-23170, 23170, 23170,-23170, 23170,-23170],
  [ 23170, 23170, 23170, 23170, 23170,-23170, 23170,-23170,-23170, 23170,-23170, 23170],
  [ 23170, 23170, 23170, 23170, 23170,-23170,-23170, 23170, 23170,-23170, 23170,-23170],
  [-23170, 23170,-23170,-23170, 23170, 23170,-23170,-23170,-23170,-23170,-23170,-23170],
  [-23170,-23170,-23170,-23170, 23170,-23170,-23170,-23170, 23170,-23170, 23170,-23170],
  [-23170, 23170,-23170, 23170,-23170,-23170, 23170, 23170,-23170, 23170, 23170,-23170],
  [-23170,-23170, 23170,-23170,-23170, 23170, 23170, 23170, 23170,-23170,-23170,-23170],
  [-23170,-23170,-23170,-23170, 23170,-23170,-23170, 23170,-23170, 23170,-23170,-23170],
  [-23170, 23170,-23170,-23170,-23170, 23170,-23170,-23170,-23170,-23170, 23170,-23170],
  [-23170, 23170, 23170,-23170, 23170,-23170,-23170,-23170, 23170,-23170,-23170,-23170],
  [-23170,-23170, 23170, 23170,-23170,-23170,-23170, 23170, 23170, 23170, 23170, 23170],
  [ 23170, 23170,-23170,-23170, 23170, 23170, 23170, 23170, 23170,-23170, 23170, 23170],
  [-23170,-23170,-23170,-23170,-23170,-23170, 23170, 23170,-23170,-23170, 23170,-23170],
  [ 23170, 23170,-23170, 23170, 23170, 23170, 23170, 23170, 23170,-23170,-23170, 23170],
  [-23170,-23170,-23170,-23170,-23170,-23170,-23170, 23170, 23170, 23170,-23170,-23170]
  ]

#Table 5.2.2.2-2 (Im part) TS 38.211 Subclause 5.2.2.2 Base sequences of length less than 36 (M_ZC=12)
table_5_2_2_2_2_Im = [[-23170, 23170,-23170,-23170,-23170, 23170,-23170,-23170, 23170, 23170, 23170,-23170],
  [-23170, 23170, 23170,-23170, 23170, 23170,-23170,-23170, 23170, 23170, 23170, 23170],
  [-23170, 23170, 23170, 23170,-23170, 23170,-23170, 23170, 23170,-23170, 23170,-23170],
  [-23170,-23170,-23170, 23170, 23170, 23170,-23170, 23170,-23170, 23170,-23170,-23170],
  [-23170,-23170,-23170, 23170, 23170, 23170, 23170,-23170, 23170,-23170,-23170, 23170],
  [-23170,-23170, 23170, 23170,-23170,-23170,-23170,-23170, 23170,-23170, 23170, 23170],
  [ 23170,-23170, 23170,-23170,-23170,-23170,-23170,-23170, 23170, 23170, 23170,-23170],
  [-23170,-23170, 23170,-23170,-23170,-23170,-23170,-23170, 23170,-23170, 23170,-23170],
  [-23170,-23170, 23170, 23170,-23170,-23170,-23170, 23170, 23170, 23170, 23170, 23170],
  [-23170,-23170,-23170,-23170,-23170,-23170,-23170, 23170, 23170, 23170,-23170,-23170],
  [-23170, 23170,-23170, 23170, 23170,-23170,-23170,-23170, 23170, 23170, 23170,-23170],
  [-23170,-23170,-23170,-23170,-23170,-23170, 23170, 23170,-23170,-23170, 23170,-23170],
  [-23170,-23170, 23170,-23170,-23170,-23170,-23170, 23170,-23170,-23170, 23170, 23170],
  [-23170, 23170,-23170,-23170, 23170, 23170,-23170,-23170,-23170,-23170,-23170,-23170],
  [ 23170, 23170,-23170, 23170, 23170, 23170, 23170, 23170,-23170, 23170,-23170, 23170],
  [-23170, 23170, 23170,-23170,-23170,-23170,-23170,-23170,-23170, 23170, 23170,-23170],
  [-23170,-23170,-23170,-23170, 23170,-23170,-23170, 23170, 23170,-23170,-23170, 23170],
  [-23170, 23170, 23170,-23170, 23170, 23170, 23170,-23170,-23170,-23170, 23170,-23170],
  [-23170, 23170, 23170, 23170,-23170,-23170,-23170, 23170, 23170,-23170, 23170,-23170],
  [-23170,-23170, 23170,-23170,-23170, 23170, 23170, 23170,-23170,-23170, 23170,-23170],
  [ 23170, 23170, 23170, 23170, 23170,-23170,-23170, 23170, 23170, 23170,-23170,-23170],
  [-23170, 23170, 23170, 23170,-23170, 23170, 23170, 23170, 23170, 23170,-23170, 23170],
  [-23170, 23170, 23170, 23170,-23170,-23170,-23170,-23170,-23170, 23170, 23170,-23170],
  [ 23170,-23170,-23170, 23170,-23170,-23170, 23170, 23170, 23170,-23170,-23170,-23170],
  [-23170,-23170, 23170,-23170, 23170, 23170, 23170, 23170,-23170,-23170, 23170, 23170],
  [-23170, 23170, 23170,-23170, 23170, 23170,-23170, 23170,-23170, 23170,-23170, 23170],
  [-23170, 23170, 23170,-23170, 23170,-23170, 23170,-23170,-23170,-23170, 23170,-23170],
  [-23170,-23170, 23170, 23170, 23170,-23170,-23170, 23170,-23170, 23170, 23170,-23170],
  [ 23170,-23170, 23170, 23170, 23170,-23170,-23170,-23170, 23170, 23170,-23170, 23170],
  [-23170, 23170,-23170, 23170,-23170,-23170, 23170,-23170,-23170, 23170, 23170,-23170]
  ]

table_5_2_2_2_2 = numpy.array(table_5_2_2_2_2_Re) + 1j * numpy.array(table_5_2_2_2_2_Im)

#Table 5.2.2.2-2 TS 38.211 Subclause 5.2.2.2 Base sequences of length less than 36 (M_ZC=12)
table_5_2_2_2_2_standart = [
  [-3,   1,  -3,  -3,  -3,   3,  -3,  -1,   1,   1,   1,  -3],
  [-3,   3,   1,  -3,   1,   3,  -1,  -1,   1,   3,   3,   3],
  [-3,   3,   3,   1,  -3,   3,  -1,   1,   3,  -3,   3,  -3],
  [-3,  -3,  -1,   3,   3,   3,  -3,   3,  -3,   1,  -1,  -3],
  [-3,  -1,  -1,   1,   3,   1,   1,  -1,   1,  -1,  -3,   1],
  [-3,  -3,   3,   1,  -3,  -3,  -3,  -1,   3,  -1,   1,   3],
  [ 1,  -1,   3,  -1,  -1,  -1,  -3,  -1,   1,   1,   1,  -3],
  [-1,  -3,   3,  -1,  -3,  -3,  -3,  -1,   1,  -1,   1,  -3],
  [-3,  -1,   3,   1,  -3,  -1,  -3,   3,   1,   3,   3,   1],
  [-3,  -1,  -1,  -3,  -3,  -1,  -3,   3,   1,   3,  -1,  -3],
  [-3,   3,  -3,   3,   3,  -3,  -1,  -1,   3,   3,   1,  -3],
  [-3,  -1,  -3,  -1,  -1,  -3,   3,   3,  -1,  -1,   1,  -3],
  [-3,  -1,   3,  -3,  -3,  -1,  -3,   1,  -1,  -3,   3,   3],
  [-3,   1,  -1,  -1,   3,   3,  -3,  -1,  -1,  -3,  -1,  -3],
  [ 1,   3,  -3,   1,   3,   3,   3,   1,  -1,   1,  -1,   3],
  [-3,   1,   3,  -1,  -1,  -3,  -3,  -1,  -1,   3,   1,  -3],
  [-1,  -1,  -1,  -1,   1,  -3,  -1,   3,   3,  -1,  -3,   1],
  [-1,   1,   1,  -1,   1,   3,   3,  -1,  -1,  -3,   1,  -3],
  [-3,   1,   3,   3,  -1,  -1,  -3,   3,   3,  -3,   3,  -3],
  [-3,  -3,   3,  -3,  -1,   3,   3,   3,  -1,  -3,   1,  -3],
  [ 3,   1,   3,   1,   3,  -3,  -1,   1,   3,   1,  -1,  -3],
  [-3,   3,   1,   3,  -3,   1,   1,   1,   1,   3,  -3,   3],
  [-3,   3,   3,   3,  -1,  -3,  -3,  -1,  -3,   1,   3,  -3],
  [ 3,  -1,  -3,   3,  -3,  -1,   3,   3,   3,  -3,  -1,  -3],
  [-3,  -1,   1,  -3,   1,   3,   3,   3,  -1,  -3,   3,   3],
  [-3,   3,   1,  -1,   3,   3,  -3,   1,  -1,   1,  -1,   1],
  [-1,   1,   3,  -3,   1,  -1,   1,  -1,  -1,  -3,   1,  -1],
  [-3,  -3,   3,   3,   3,  -3,  -1,   1,  -3,   3,   1,  -3],
  [ 1,  -1,   3,   1,   1,  -1,  -1,  -1,   1,   3,  -3,   1],
  [-3,   3,  -3,   3,  -3,  -3,   3,  -1,  -1,   1,   3,  -3]
]

#The following tables implement TS 38.211 table 6.3.2.4.1-2: Orthogonal sequences wi(m)=exp(j*2*pi*phi(m)/N_SF) for PUCCH format 1
table_6_3_2_4_1_2_Wi_standart = [
  [[0,],                  [0,],                  [0,],                  [0,],                  [0,],                  [0,],                  [0,]],
  [[0,],                  [0,],                  [0,],                  [0,],                  [0,],                  [0,],                  [0,]],
  [[0, 0],                [0, 1],                [0,],                  [0,],                  [0,],                  [0,],                  [0,]],
  [[0, 0, 0],             [0, 1, 2],             [0, 2, 1],             [0,],                  [0,],                  [0,],                  [0,]],
  [[0, 0, 0, 0],          [0, 2, 0, 2],          [0, 0, 2, 2],          [0, 2, 2, 0],          [0,],                  [0,],                  [0,]],
  [[0, 0, 0, 0, 0],       [0, 1, 2, 3, 4],       [0, 2, 4, 1, 3],       [0, 3, 1, 4, 2],       [0, 4, 3, 2, 1],       [0,],                  [0,]],
  [[0, 0, 0, 0, 0, 0],    [0, 1, 2, 3, 4, 5],    [0, 2, 4, 0, 2, 4],    [0, 3, 0, 3, 0, 3],    [0, 4, 2, 0, 4, 2],    [0, 5, 4, 3, 2, 1],    [0,]],
  [[0, 0, 0, 0, 0, 0, 0], [0, 1, 2, 3, 4, 5, 6], [0, 2, 4, 6, 1, 3, 5], [0, 3, 6, 2, 5, 1, 4], [0, 4, 1, 5, 2, 6, 3], [0, 5, 3, 1, 6, 4, 2], [0, 6, 5, 4, 3, 2, 1]]
]

table_6_3_2_4_1_1_N_SF_mprime_PUCCH_1_noHop = [0,0,0,2,2,3,3,4,4,5,5,6,6,7]
table_6_3_2_4_1_1_N_SF_mprime_PUCCH_1_m0Hop = [0,0,0,1,1,1,1,2,2,2,2,3,3,3]
table_6_3_2_4_1_1_N_SF_mprime_PUCCH_1_m1Hop = [0,0,0,1,1,2,2,2,2,3,3,3,3,4]
table_6_4_1_3_1_1_1_N_SF_mprime_PUCCH_1_noHop = [0,0,0,2,3,3,4,4,5,5,6,6,7,7]
table_6_4_1_3_1_1_1_N_SF_mprime_PUCCH_1_m0Hop = [0,0,0,1,1,2,2,2,2,3,3,3,3,4]
table_6_4_1_3_1_1_1_N_SF_mprime_PUCCH_1_m1Hop = [0,0,0,1,2,1,2,2,3,2,3,3,4,3]

table1_mcs = [0, 6, 3, 9];
table2_mcs = [0, 3, 9, 6, 1, 4, 10, 7];

def get_mcs(sr_flag, nr_bit, actual_payload):
  mcs = 0
  
  shift = 0
  if (sr_flag):
    shift = 1 << nr_bit;
  if (nr_bit == 0):
    mcs = table1_mcs[0];
  elif (nr_bit == 1):
    mcs = table1_mcs[actual_payload + shift];
  elif (nr_bit == 2):
    mcs = table2_mcs[actual_payload + shift];
  else:
    print(f"Either nr_bit {nr_bit} or sr_flag {sr_flag} must be non-zero\n");
  
  return mcs
  
def get_d(n_bit, payload, amp):
  d = 0
  if n_bit == 1:
    if payload & 1 == 0:
      d = ( 1 / math.sqrt(2) + 1J / math.sqrt(2)) * amp 
    else:
      d = (-1 / math.sqrt(2) - 1J / math.sqrt(2)) * amp 
  elif n_bit == 2:
    if (payload & 1 == 0) and ((payload >> 1) & 1 == 0):
      d = ( 1 / math.sqrt(2) + 1J / math.sqrt(2)) * amp 
    elif (payload & 1 == 0) and ((payload >> 1) & 1 == 1):
      d = ( 1 / math.sqrt(2) - 1J / math.sqrt(2)) * amp 
    elif (payload & 1 == 1) and ((payload >> 1) & 1 == 0):
      d = (-1 / math.sqrt(2) + 1J / math.sqrt(2)) * amp 
    elif (payload & 1 == 1) and ((payload >> 1) & 1 == 1):
      d = (-1 / math.sqrt(2) - 1J / math.sqrt(2)) * amp  
  return d
  
def lte_gold_generic(x1, x2, reset):
  if (reset):
    x1 = 1 + (1 << 31)
    x2 = x2 ^ (((x2 ^ (x2 >> 1) ^ (x2 >> 2) ^ (x2 >> 3)) << 31) & 0xffffffff)
    for n in range(1,50):
      x1 = (x1 >> 1) ^ (x1 >> 4)
      x1 = x1 ^ ((x1 << 31) ^ (x1 << 28)) & 0xffffffff
      x2 = (x2 >> 1) ^ (x2 >> 2) ^ (x2 >> 3) ^ (x2 >> 4)
      x2 = x2 ^ ((x2 << 31) ^ (x2 << 30) ^ (x2 << 29) ^ (x2 << 28)) & 0xffffffff
     
  x1 = (x1 >> 1) ^ (x1 >> 4)
  x1 = x1 ^ ((x1 << 31) ^ (x1 << 28))&0xffffffff
  x2 = (x2 >> 1) ^ (x2 >> 2) ^ (x2 >> 3) ^ (x2 >> 4)
  x2 = x2 ^ ((x2 << 31) ^ (x2 << 30) ^ (x2 << 29) ^ (x2 << 28)) & 0xffffffff
  return (x1 ^ x2), x1, x2

def get_group_swq_hopping(group_hop, n_id, n_hop, nr_tti_tx):
  u = 0; v = 0
  f_ss = 0; f_gh = 0
  l = 32
  c_init = 0
  x1 = 0; x2 = c_init
  tmp_shift = 0
  min_shift = (2 * nr_tti_tx + n_hop) << 3
  
  #group_hop == nizer
  if group_hop == 0:
    f_ss = n_id % 30
  
  #group_hop == enable
  if group_hop == 1:
    c_init = int(n_id / 30)
    x2 = c_init
    s, x1, x2 = lte_gold_generic(x1, x2, 1)
    
    for m in range(0, 8):
      while min_shift >= l:
        s, x1, x2 = lte_gold_generic(x1, x2, 0)
        l = l + 32
    
      tmp_shift = (min_shift & ((1 << 5) - 1)); #minShift%32;
      min_shift = min_shift + 1;
      f_gh = f_gh + ((1 << m) * (((s >> tmp_shift) & 1)) & 0xff);
    
    f_gh = f_gh%30;
    f_ss = n_id%30;

  #group_hop == disable
  if group_hop == 2:
    c_init = (1 << 5) * int(n_id / 30) + (n_id % 30)
    x2 = c_init
    s, x1, x2 = lte_gold_generic(x1, x2, 1)
    
    while min_shift >= l:
      s, x1, x2 = lte_gold_generic(x1, x2, 0)
      l = l + 32
    
    tmp_shift = (min_shift & ((1 << 5) - 1)); #minShift%32;
    min_shift = min_shift + 1;
    v = (((s >> (2 * nr_tti_tx + n_hop)) & 1)) & 0xff;
    
  u = (f_gh + f_ss) % 30
    
  return (u, v)
   
def get_ncs(n_id,l_norm,l_prime,nr_tti_tx):
  n_cs = 0
  l = 32
  c_init = n_id
  x1 = 0; x2 = c_init
  s, x1, x2 = lte_gold_generic(x1, x2, 1)
  tmp_shift = 0
  min_shift = (14 * 8 * nr_tti_tx) + 8 * (l_norm + l_prime)
  for m in range(0, 8):
    while min_shift >= l:
      s, x1, x2 = lte_gold_generic(x1, x2, 0)
      l = l + 32
    
    tmp_shift = (min_shift & ((1 << 5) - 1)); #minShift%32;
    min_shift = min_shift + 1;
    n_cs = n_cs + ((1 << m) * (((s >> tmp_shift) & 1)) & 0xff);
    
  return n_cs

def get_alpha(ncs, m0, mcs):
  alpha = math.pi / 6 * ((m0 + mcs + ncs) % 12)
  return alpha

if __name__ == '__main__':
  print(table_5_2_2_2_2)